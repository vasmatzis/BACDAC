% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ploidy.R
\name{calculatePloidy}
\alias{calculatePloidy}
\title{Determines ploidy of a given sample}
\usage{
calculatePloidy(
  sampleId,
  outputDir,
  alternateId = NULL,
  readDepthPer30kbBin = NULL,
  readDepthPer100kbBin = NULL,
  segmentation,
  segmentationBinSize = 30000,
  hetScoreData,
  numChroms = 24,
  centroArray,
  dPeaksCutoff = 0.01,
  penaltyCoefForAddingGrids = 0.49,
  minGridHeight = 0.2,
  minPeriodManual = -1,
  maxPeriodManual = -1,
  grabDataPercentManual = -1,
  origMaxPercentCutoffManual = -1,
  pause = FALSE,
  noPdf = FALSE,
  skipExtras = FALSE,
  forceFirstDigPeakCopyNum = -1,
  minReasonableSegmentSize = 5500000,
  omitAnnotations = FALSE,
  heterozygosityScoreThreshold = 0.98,
  allowedTumorPercent = 106,
  hsNormMat = NULL
)
}
\arguments{
\item{sampleId}{sample Identifier}

\item{alternateId}{secondary sample identifier}

\item{readDepthPer30kbBin}{read depth for 30 kb bins, with bin index in linear coordinates}

\item{segmentation}{identified regions of the genome with constant read depth. Contains chromosome, start, end, expected CNV, actual CNV and other values we do not need.}

\item{segmentationBinSize}{bin size used for the read depth in the segmentation data}

\item{hetScoreData}{heterozygosity scores determined per 30 kb bin over a 1 Mb region}

\item{numChroms}{number of chromosomes in the reference genome to consider}

\item{centroArray}{array with the positions of the centromeres for each chromosome}

\item{dPeaksCutoff}{dPeaksCutoff min grid height for a peak to be considered a digital peak}

\item{penaltyCoefForAddingGrids}{penalty for adding additional peaks to the digital peak alignment}

\item{minGridHeight}{minimum value that can be assigned to the gridHeights}

\item{minPeriodManual}{manually set \code{minPeriod} within \code{calculatePloidy}}

\item{maxPeriodManual}{manually set \code{maxPeriod} within \code{calculatePloidy}}

\item{grabDataPercentManual}{portion of main peak data to grab, other peaks will be scaled based on read depth (x location), set to -1 to base off of mainPeak width}

\item{origMaxPercentCutoffManual}{peaks smaller than this portion of the max peak are not considered; set to -1 to use default value}

\item{pause}{pause execution until user prompts to continue, available interactively only, useful during testing}

\item{skipExtras}{logical to turn on/off plots used for testing and debugging}

\item{forceFirstDigPeakCopyNum}{value to force copy number of first digital peak, use only when ploidy calculation is wrong}

\item{minReasonableSegmentSize}{initial smallest segment size to include in ploidy test segments; want to keep as large as possible to avoid 0N segments, but will decrease size if not enough segments are found}

\item{hsNormMat}{}
}
\value{
expReadsIn2NPeak_1bp, percentTumor, peakInfo, hetScoreQuantiles

wrap steps to repeat into a function:
add 'nCopy' to peaksInfo, construct hetScoreQuantiles, calculate Tumor
}
\description{
Fit the peaks from the read depth distributions to a digital grid.
Evaluate the heterozygosity score to determine if first digital peak is 1N or 2N.
Then find the expected number of reads in the 2N peak and normalize that value to one bp. Tumor percent is calcuated from the two biggest digital peaks.
}
\examples{
\dontrun{
  library(BACDAC)
  # calculateHetScoreExample.R
  basicConfig("DEBUG")
  noPdf=TRUE                          # TRUE= print to screen, FALSE=print to pdf (i e. outputDir/dev/ploidy)
  # outputDir = tempdir();              # output folder for pdfs etc.
  outputDir='/research/labs/experpath/vasm/shared/NextGen/johnsonsh/Routput/BACDAC'
  sampleId='TCGA-14-1402-02A_ds'; alternateId=66301

  ### load data ###
  inputDir <- system.file('extdata', package = "BACDAC") # or '/research/labs/experpath/vasm/shared/NextGen/johnsonsh/Rprojects/BACDAC/inst/extdata'

  # hetScores from 23 Normals,  101046 x 23 rows, one row for each 30kb segment of the genome, 1-22, X and a part of Y. Columns are values for each of the 23 Normals for each segment
  # TODO: can I also make this example data? or should it be downloaded separately? file size= 18.6M
  hsNormMat <- bmdTools::loadRdata('/research/labs/experpath/vasm/shared/NextGen/Misc/pipelineInputs/hetScoreAnalysis/lohMat.Rdata') # aka lohMat

  # segmentation data
  segmentationFile <- file.path(inputDir, paste0(sampleId, '_segmentation.csv'))
  segmentation= loadSegmentationFile(segmentationFile)

  # hetScore data - the output from calculateHetScore()
  hetScoreDir='/research/labs/experpath/vasm/shared/NextGen/johnsonsh/Routput/BACDAC/reports'
  hetScorePerBinWigFile <- file.path(hetScoreDir, paste0(sampleId, '_hetScorePerBin.wig.gz'))
  hetScoreData <- as.data.frame(rtracklayer::import.wig(hetScorePerBinWigFile))

  # read depth data
  thirtyKbFile=file.path(inputDir, paste0(sampleId,'_','readDepthPer30kbBin.Rds'))
  readDepthPer30kbBin = readRDS(file=thirtyKbFile )
  hundredKbFile=file.path(inputDir, paste0(sampleId,'_','readDepthPer100kbBin.Rds'))
  readDepthPer100kbBin = readRDS(file=hundredKbFile )





  # defaults
  segmentationBinSize=30000; numChroms=24;
  centroArray <- getCentromerePositions(ideogram = ideogram)
  pause=FALSE; skipExtras=FALSE; omitAnnotations = FALSE;
  dPeaksCutoff=0.01;    penaltyCoefForAddingGrids=0.49; minGridHeight=0.2; minPeriodManual=-1; maxPeriodManual=-1; forceFirstDigPeakCopyNum=-1;   # digital peaks
  grabDataPercentManual= -1; origMaxPercentCutoffManual=-1;  #  peaksByDensity
  minReasonableSegmentSize=5.5e6;
  heterozygosityScoreThreshold=0.98;  # If segment hetScore is more than this, the segment is heterozygous
  allowedTumorPercent = 106


  ### call calculatePloidy, the function to do all the ploidy work ---------
  loginfo('calculate ploidy for \%s ', sampleId)
  result=calculatePloidy(sampleId=sampleId, outputDir = outputDir, noPdf=noPdf, alternateId=alternateId,
                         readDepthPer30kbBin = readDepthPer30kbBin, readDepthPer100kbBin= readDepthPer100kbBin,
                         segmentation=segmentation, centroArray = centroArray, hetScoreData = hetScoreData,

                         segmentationBinSize=segmentationBinSize, numChroms=numChroms,
                         pause=pause, skipExtras=skipExtras, omitAnnotations = omitAnnotations,

                         dPeaksCutoff=dPeaksCutoff,    penaltyCoefForAddingGrids=penaltyCoefForAddingGrids, minGridHeight=minGridHeight, minPeriodManual=minPeriodManual, maxPeriodManual=maxPeriodManual, forceFirstDigPeakCopyNum=forceFirstDigPeakCopyNum,   # digital peaks
                         grabDataPercentManual= grabDataPercentManual,  origMaxPercentCutoffManual=origMaxPercentCutoffManual,  #  peaksByDensity

                         minReasonableSegmentSize=minReasonableSegmentSize,
                         heterozygosityScoreThreshold=heterozygosityScoreThreshold,  # If segment hetScore is more than this, the segment is heterozygous
                         allowedTumorPercent = allowedTumorPercent,
                         hsNormMat=hsNormMat
  )

  calcPloidyResultOutputFile=file.path(outputDir, paste0(sampleId, '_calculatePloidyResult.Rds'))
  loginfo('saving result to: \%s',calcPloidyResultOutputFile)
  saveRDS(result, file=calcPloidyResultOutputFile)

  print(result)

  mainPeakIndex = which(result$peakInfo$rankByHeight==1)
  loginfo('Main peak is \%sN',result$peakInfo[mainPeakIndex,'nCopy'])
  loginfo('tumor percentage: \%s ',round(result$percentTumor) )
  loginfo('approximate ploidy: \%s ',round( mean(result$segmentData$cnLevel),1) ) # based on segment copy number and not adjusted for size


}
}
